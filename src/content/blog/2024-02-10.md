---
title: "Wildcard Matching"
category: "LeetCode"
date: 2024-02-10
---
## Problem Statement:
Given a string $s$ $(0 \leq |s| \leq 2000)$ and pattern $p$ $(0 \leq |p| \leq 2000)$, implement wildcard pattern matching where:
- `'?'` Matches any single character.
- `'*'` Matches any sequence of characters (including the empty sequence).

$p$ should match $s$ in its entirety.

## Solution:
### Breakdown
Let's define a function $f$ as:
$$
f(i,j)=\begin{cases}
0 & p[j:] \text{ doesn't match } s[i:]\\
1 & p[j:] \text{ matches } s[i:]
\end{cases}
$$

The answer to this problem is $f(0,0)$.

For each $(i,j)$ pair, the cases are:
#### Case 1: $p[j] = $ `'?'`
$$
f(i,j) = f(i+1,j+1).
$$
#### Case 2: $p[j] = $ `'*'`
A decision can be made to include no characters, some of the remaining characters, or all of the remaining characters.
A search is necessary through all of these cases.

In mathematical notation:
$$
f(i,j) = \max\left(\sum_{k=i}^{|s|} f(k,j+1), 1\right)
$$

#### Case 3: $p[j] \neq $  `'?'`, `'*'`
If $s[i] = p[j]$:
$$
f(i,j) = f(i+1,j+1)
$$
Otherwise:
$$
f(i,j) = 0
$$
### Implementation
With standard recursion, the runtime complexity approaches $O(2^{|s|})$.

To optimize this, notice that there are only a maximum of $(|s| + 1) \times (|p| + 1) \leq 4004001$ possible values of $f$.
Memoizing the pairs brings the time complexity down to $O(|s|^2 \times |p|)$.

```java
class Solution {
    public boolean isMatch(String s, String p) {
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        for (int i = s.length(); i >= 0; i--) {
            for (int j = p.length(); j >= 0; j--) {
                if (i == s.length() && j == p.length())
                    dp[i][j] = true;
                else if (i == s.length())
                    dp[i][j] = p.charAt(j) == '*' && dp[i][j + 1];
                else if (j == p.length())
                    dp[i][j] = false;
                else {
                    if (p.charAt(j) == '?')
                        dp[i][j] = dp[i + 1][j + 1];
                    else if (p.charAt(j) == '*')
                        for (int k = i; k <= s.length(); k++)
                            dp[i][j] |= dp[k][j + 1];
                    else
                        dp[i][j] = s.charAt(i) == p.charAt(j) && dp[i + 1][j + 1];
                }
            }
        }
        return dp[0][0];
    }
}
```

Finally, to bring down the time complexity to $O(|s| \times |p|)$, notice the excess amount of work being done in case 2.
If there is already a loop of $i$ going backwards, cache the result of $dp[i][j+1]$ in a boolean if that boolean isn't already $1$.

```java
class Solution {
    public boolean isMatch(String s, String p) {
        boolean[][] dp = new boolean[s.length() + 1][p.length() + 1];
        for (int j = p.length(); j >= 0; j--) {
            boolean b = false;
            for (int i = s.length(); i >= 0; i--) {
                b |= j < p.length() && dp[i][j + 1];
                if (i == s.length() && j == p.length())
                    dp[i][j] = true;
                else if (i == s.length())
                    dp[i][j] = p.charAt(j) == '*' && dp[i][j + 1];
                else if (j == p.length())
                    dp[i][j] = false;
                else {
                    if (p.charAt(j) == '?')
                        dp[i][j] = dp[i + 1][j + 1];
                    else if (p.charAt(j) == '*')
                        dp[i][j] = b;
                    else
                        dp[i][j] = s.charAt(i) == p.charAt(j) && dp[i + 1][j + 1];
                }
            }
        }
        return dp[0][0];
    }
}
```
